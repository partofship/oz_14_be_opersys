## 파일 - 디렉토리

> 파일과 디렉터리는 운영체제가 보조기억장치에 저장된 데이터를 체계적으로 관리하기 위해 제공하는 `핵심 추상화 기능`

---

### 파일

- 파일: 의미있는 정보를 한 덩어리로 모아둔 논리적 단위.
- 실행될 때는 메인 메모리를 사용. (OS가 메인 메모리로 옮김)
- 실제 저장위치: (물리적으로) HDD, SSD
- 영속적인 저장 단위이며 메모리는 실행을 위한 일시적인 작업 공간
- 냉장고(SSD) → 메모리(부엌), 파일: 식자재
- 구성 요소: 파일 이름, 실행에 필요한 정보, 메타데이터(=파일의 속성)
- <b>확장자</b>: 파일 이름의 일부. 식별 정보 = 어떤 데이터를 담고 있는지 OS와 응용프로그램에 알려줌
- 예: 이미지 파일, 동영상 파일 등
- 파일에 대한 조작은 운영체제를 통해서만 이루어짐
- 응용프로그램은 시스템 호출을 통해 (파일에 대한 접근을) 운영체제에 요청 → OS: 접근 권한 검사, 장치 드라이버 통해 접근 → 결과를 응용 프로그램에 전달
- 파일 시스템의 일관성·보안성 유지

---

### 디렉터리

- `논리적 단위`: 파일을 체계적으로 정리하고 분류할 수 있도록 운영체제가 제공하는 논리적 구조.
- 흔히 사용하는 폴더 = 디렉터리
- 한 디렉터리는 N개의 파일과 N개의 하위 디렉터리를 가질 수 있음 (= 계층적 트리 구조의 파일 스스템 구성)
    - 대량의 파일을 효율적으로 관리하고 빠르게 탐색 가능
- OS 내부적으론 하나의 특수한 파일로 취급됨.
    - 디렉터리는 파일의 이름·저장 위치·메타데이터 가리키는 정보를 테이블 형태로 저장하는 파일
    - 테이블의 각 행Column은 하나의 파일/하위 디렉터리 대응 = 디렉터리 엔터리로 지칭
    - 디렉터리 엔터리에는 파일 이름과 함께 해당 파일이 디스크 상에서 저장된 위치를 참조할 수 있는 정보 有

---

### 파일 시스템

- 파일 + 디렉터리 결합된 논리적 조직 구조
- 담당: 파일의 생성·삭제·디렉터리 구조 관리·저장 공간 할당·접근 권한 통제·데이터 무결성 유지
- 장점) 응용프로그램 - 파일 시스템 구조 직접 알 필요 X → 운영체제가 제공하는 파일 시스템 인터페이스 통해 파일/디렉터리를 일관된 방식으로 사용


## 파일과 메모리

> 파일과 메모리는 저장 장치와 주기억장치라는 서로 다른 계층에 존재하지만, OS는 파일을 메모리와 연계 + 파일을 블록 단위로 관리 → 입출력 수행함. <br> 한 파일은 RAM에서 여러 개의 고정 크기 블록으로 분할+저장, OS는 `파일 할당 방법`을 통해 블록을 어떻게 할당할 것인지 결정. <br>파일 할당 방식은 연속 할당 방식과 불연속 할당 방식으로 구분.

> 파일의 


---

### 연속 할당 방식

- 하나의 파일을 디스크상의 연속된 블록에 순차적으로 저장
- 우수함: 파일의 시작 블록 주소 + 전체 블록 개수만 알면 모든 데이터로 빠르게 접근 가능
    - 즉, 순차 접근/임의 접근 성능 good
- 단점
    - 파일 크기 증가할 경우 → 확장 불가
    - `외부 단편화` in 저장 장치: 삭제된 파일로 인해 심하게 발생

---

### 불연속 할당 방식

- 파일의 블록을 디스크 내 임의의 위치에 분산해 저장
- 중요 예시: 연결 할당 방식 (= 연결 리스트 방식)
- 각 블록이 다음 블록 주소를 포인터 형태로 저장
- 파일: 해당 블록이 논리적으로 연결된 연결 리스트 구조로 구성
- 연속 공간이 필요 없는 방식
    1) 외부 단편화 문제 발생 X
    2) 파일 확장 자유로움
- 단점
    1) 임의 접근 성능 낮음: 특정 위치 블록에 직접 접근하려면 처음 블록부터 순차적으로 따라가야 함
    2) 포인터 손상되면 파일 전체 손상될 수 있음
- 그러면 기술적으로 부정확한 명칭 아닌가욤? ㅎㅎ

<br>

- 중요 예시: 인덱스 할당 방식
- 파일마다 한 인덱스 블록을 두고 해당 파일을 구성하는 모든 데이터 블록 주소를 이 인덱스 블록에 테이블 형태로 저장
- 장점: 임의 접근 가능 + 외부 단편화 제거
- 단점
    1) 인덱스 블록 자체를 위한 추가 공간 필요
    2) 파일 크기 너무 커질 경우 → 인덱스 구조가 복잡해짐