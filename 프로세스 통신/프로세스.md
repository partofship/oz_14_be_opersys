### (복습) 프로그램 실행 과정

- `프로그램` 경로: from 보조 저장 장치 → 주 기억장치
- convert into: `프로세스`
- OS: 프로그램을 파일로 인식X `실행 단위` (CPU 자원 소비하는) + 스케줄링 대상 포함 ✅
- 프로세스: 다음을 메모리에 할당받고 독립적 실행 환경 구성: 코드 영역, 데이터 영역, 스택 영역, 힙 영역

### 프로세스, 프로세스 제어 블록 PCB, 컨텍스트 스위칭
`Process Control Block`
- OS는 프로세스를 매우 빠른 속도로 번갈아 실행
- 프로세스란, 명령을 실행 중인 상태인 프로그램.
- Issue: 실행 상태를 정확히 저장/복원해야 멀티테스킹이 가능
- 프로세스를 식별하고 제어하기 위한 핵심 관리 자료구조로써 모든 정보가 저장된 것: 한 프로세스마다 하나의 프로세스 제어 블록
- `컨텍스트 스위칭`: 실행 중인 프로세스를 교체 (멀티태스킹을 위해서)
    - CPU가 서로 다른 프로세스를 일정 시간이 지날때마다 중단/바꿔서 실행, 초당 수천~수백만 번 반복.

- PCB 저장되는 정보: 프로세스 식별 정보 | 프로세스 상태 정보| CPU 레지스터 정보 | 스케줄링 정보 | 메모리 관리 정보 | 입출력, 자원 정보
    - 프로세스 식별 정보:
        - [식별 수단] ← 프로세스ID, 부모 프로세스ID, 사용자ID, 그룹 ID 등
    - 프로세스 상태 정보
        - 실행 단계 저장 (New, Ready, Running, Waiting, Terminated)
        - 스케줄러는 해당 정보를 기준으로 실행 대상 프로세스 선택
    - CPU 레지스터 정보
        - 저장: 프로세스가 마지막으로 실행되던 순간의 CPU 내부 상태 (있어야 중단된 시점에서 정확히 실행 재개 가능)
        - 대상: 프로그램 카운터·스택 포인터·일반 레지스터·플래그 레지스터
    - 스케줄링 정보: 운영체제가 다음 실행할 프로세스 결정할 때 사용
        - 대상: 프로세스 우선순위, 포인터(준비 Queue, 대기 Queue 가리킴), CPU 사용 시간
    - 메모리 관리 정보: 프로세스가 사용하는 메모리 공간 보호 + 추적하기 위한 기준 제공
        - 대상: 페이지 테이블 주소·세그먼트 테이블·코드 영역·데이터 영역·스택·힙/메모리 배치 정보
    - 입출력, 자원 정보: 자원 충돌/누수 방지
        - 대상: 파일 목록(프로세스가 개봉한), 사용 중 장치, 소켓, 파이프 같은 통신 자원 정보

### 프로세스 생성
CPU 자원을 소모하는 실행 단위.

- (속도) 기존 프로세스 복사 방식 ＞ 새로운 프로세스 생성 
- `FORK` : 프로세스의 복사
- 대부분 OS에서 모든 프로세스는 최초의 프로세스로부터 복사됨.
- FORK 될 때 부모 프로세스의 `코드·데이터·실행 환경`을 복제

### 스레드
실행 단위 of 하나의 프로세스 내부에서 갈라진 (작업을 나누어 처리하기 위해)
- 컨텍스트 스위칭: 프로세스 간 전환 시 발생하는 비용 多
- 구조: for 부하 감소, 한 프로세스 in 스레드s
- 프로세스보다 생성·전환비용이 적다
- 스레드는 생성될 때마다 자신만의 스택 영역만 추가로 제공받음
- 소속된 프로세스와 공유: `코드 영역·데이터 영역·힙 영역`
    - 코드 영역: 스레드도 프로세스가 수행해야 할 작업을 실행해야 하기 때문에
    - 데이터/힙 영역: 전역/정적 변수와 동적 메모리에 접근해야 하기 때문에

### CPU 스케줄링 or 프로세스 스케줄링
CPU가 여러 프로세스를 빠르게 번갈아 실행하기 위해 각 프로세스에 CPU 사용 시간 나누어 배분하는 과정

- 모든 프로세스에 동일한 빈도로 CPU 할당 → 비합리적. 많은 문제 발생
- 운영체제는 각 프로세스에 우선순위 부여, 실행 순서를 결정
- 프로세스 中: CPU 자주 요구 / 실시간 처리 필요 / 백그라운드 작업 - 다른 우선순위 가짐
- OS는 *큐 자료구조* 사용. 프로세스 상태를 관리하기 위해서.
    - 준비 큐Queue: 프로세스 of 실행 가능한 상태
    - 대기 큐: 프로세스 of 입출력 완료 등을 기다림
    - 프로세스: 준비 큐에서 실행할 프로세스 선택 → CPU 할당
- 스케줄링 알고리즘: 기준, 고려/요구사항↓
    1) 시스템 전체 부하 최소화
    2) 효율: CPU, 메모리 같은 컴퓨팅 자원 효율적으로 써야 함
    3) 균형: 특정 프로세스가 과도히 차별받지 않게 균형
    4) 체감: 사용자가 느기는 대기/응답 시간이 지나치게 길어지지 않도록
- 종류: 선입선출, 최단 작업 우선, 라운드 로빈, 우선순위 스케줄링
    - 선입선출: First Come, First Serve
    - 라운드 로빈: 모든 프로세스에 동일한 시간 할당량 부여 → 시간 종료 시 다음 프로세스 진행. 공정성 높음
    - 우선순위: 우선순위 높은 프로세스 먼저 실행. 지나치게 고려할 시 낮은 우선순위 프로세스가 장시간 실행 불가 → `기아 현상` 이라고 지칭


### 프로세스 간 통신

- 프로세스 간 통신을 위해서 필요: 통로 for 데이터 주고받을 수 있는 ▷ 메일슬롯, 파이프
- 메일슬롯: 데이터 주고받기 위한 객체 생성 - 송신자가 객체를 통해 데이터 전달 - 수신자가 데이터 수신 (단방향)
    - 양방향 통신을 위해 반대 방향 객체를 추가로 만들어야 함
- 파이프: 프로세스 간 데이터를 흐르게 하는 통로 생성 → 통신
`   - 이름 없는 파이프(네임리스): 부모-자식과 같이 서로 관계 보유한 프로세스 간 단방향 통신에 사용
    - 네임드(이름 有 파이프): 서로 무관 프로세스 사이에서 사용 가능 + 양방향 통신 可

### 동기화

임계구역 문제를 해결하기 위한 기법

- 프로세스는 원칙적으로 서로 독립적으로 실행
    - But, IPC를 통해 같은 직업 대상/데이터 공유하며 협력 가능함
    - Issue: 여러 프로세스가 동시에 같은 자원에 접근? → 문제 발생
- 공유 자원: 변수·파일·입출력 장치 - 여러 프로세스가 공동으로 사용하는
- 임계구역: 코드 영역 of 공유 자원에 동시 접근하는
    - 임계 구역에 여러 프로세스가 동시에 진입 → 실행 순서에 따라 결과가 달라지는 오류 발생

- `상호 배제`
    - 원칙: 한 프로세스가 임계구역 Enter → 다른 프로세스: 절대 진입할 수 없도록 막음
    - 구현 방식: 뮤텍스 락
    - Lock 획득한 프로세스만 임계구역 실행 / 작업 종료 시 락 해제

### 데드락

- 영원히 대기 상태에 빠지는 상황
    - 여러 프로세스가 서로 자원을 점유, 상대방이 가진 자원을 기다리기 때문
    - 순환 오류를 생각하면 됨
- 다음 네 가지 상황이 동시에 만족될 때 발생
    - 상호 배제, 비선점, 점유 및 대기, 원형 대기
    - 점유 및 대기 (점유 상태로 대기): 자원 하나를 보유한 상태에서 또 다른 자원을 기다리는 것.
        - ex) Zoom과 녹음기, 카메라 앱 + 마이크, 카메라 자원
        - Zoom: 마이크 자원 보유 but 카메라 필요 → 카메라 쓰기 위해 대기
        - 카메라 앱은 카메라 보유
        - 녹음기 앱: Zoom을 기다리기 때문에 마이크 자원 받기 전까지 대기
    - 비선점No preemption: 다른 프로세스가 자원을 가져올 방법이 없음
        - 상단 예시인 Zoom
        - 녹음기가 마이크를 강탈해 할 일을 하거나
        - Zoom이 카메라 앱을 죽이고Kill 통신 시작할 수 있음(Terminate)
        - 이런 기능이 자원을 가져올 방법
    - 원형 대기 = 순환성 대기 = Circular Wait
        - 마지막 프로세스가 첫 프로세스 사용 중 자원을 쓰기 위해 대기중인 상황
        - 식사하는 철학자 문제
        - waiting - waiting - waiting...
- 해결 방법: 예방·회피·탐지·복구
    - 예방: 교착이 일어날 상황 자체를 방지
    - 회피: 각 요청을 OS가 직접 분석 → 데드락 발생 가능성 확인
        은행원 알고리즘, Wait-Die 기법, Wound-Wait
    - 탐지: 데드락이 필연적으로 발생할 것 가정 → 현 체계 중 어디서 데드락 발생했는지 탐색
        - 자원할당 그래프 알고리즘, Wait for Graph
    - 복구: 실제 데드락 자체 해결하는 강제성 방법. 프로세스 종료, 자원 회수.
        - 프로세스 종료: 교착 상태인 프로세스를 골라서 종료. 피해를 덜 입는 프로세스를 최소한으로 골라야.
        - 자원 회수: 프로세스에 할당된 각 자원을 데드락이 사라질 때까지 강제로 회수하는 방법. OS 수준에서만 가능